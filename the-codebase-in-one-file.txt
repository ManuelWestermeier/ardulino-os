
//filepath: app-renderer.hpp
#ifndef APP_RENDERER_HPP
#define APP_RENDERER_HPP

#include <map>
#include "./globals.hpp"
#include "./utils/structs/pos.hpp"
#include "./cursor.hpp"
#include "./utils/index.hpp"

namespace AppRender
{
    String appOpened = "home";

    void UpdateView();
    void UpdateCurrentApp();
    void ExitCurrentApp();
    void ClickCurrentApp(Pos *pos);
    void ScrollCurrentApp(signed char direction);
    char GetCursorPosChar();
    void UpdateLoop(Pos pos, byte _);
    void Update();
    void SubmitCurrentApp();
    bool RenderSubmit();
};

struct AppPrototype
{
    String name;
    byte (*Start)(const String &) = nullptr;
    void (*Update)() = nullptr;
    void (*Scroll)(signed char direction) = nullptr;
    void (*OnExit)() = nullptr;
    void (*OnClick)(Pos clickPos) = nullptr;
    void (*Submit)() = nullptr;
};

std::map<String, AppPrototype> registeredApps;

void RegisterApp(AppPrototype app)
{
    registeredApps[app.name] = app;
}

#include "./init-apps.hpp"

bool AppRender::RenderSubmit()
{
    return registeredApps[appOpened].Submit != nullptr;
}

void AppRender::UpdateCurrentApp()
{
    if (!isLoggedIn)
    {
        LoginApp::Update();
        return;
    }

    if (registeredApps[appOpened].Update)
    {
        registeredApps[appOpened].Update();
    }
}

void AppRender::ExitCurrentApp()
{
    ClearAppScreen();
    if (!isLoggedIn || appOpened == "login")
    {
        utils::cantExitApp();
        return;
    }

    if (registeredApps[appOpened].OnExit)
    {
        registeredApps[appOpened].OnExit();
    }

    if (appOpened == "home")
    {
        isLoggedIn = false;
        Auth();
    }
    else
    {
        appOpened = "home";
    }
}

void AppRender::ClickCurrentApp(Pos *pos)
{
    if (!isLoggedIn)
    {
        LoginApp::OnClick(*pos);
        return;
    }

    if (registeredApps[appOpened].OnClick)
    {
        registeredApps[appOpened].OnClick(*pos);
    }
}

void AppRender::ScrollCurrentApp(signed char direction)
{
    if (!isLoggedIn)
    {
        LoginApp::Scroll(direction);
        return;
    }

    if (registeredApps[appOpened].Scroll)
    {
        registeredApps[appOpened].Scroll(direction);
    }
}

void AppRender::SubmitCurrentApp()
{
    if (registeredApps[appOpened].Submit)
    {
        registeredApps[appOpened].Submit();
    }
}

char AppRender::GetCursorPosChar()
{
    if (Cursor::pos.x < 19 && Cursor::pos.y > 0)
    {
        char charUnderCursor = appScreenData[Cursor::pos.x][Cursor::pos.y - 1];
        return charUnderCursor == ' ' ? '-' : charUnderCursor;
    }
    if (Cursor::pos.x < 16 && Cursor::pos.y == 0)
    {
        char charUnderCursor = appTitle[Cursor::pos.x];
        return charUnderCursor == ' ' ? '-' : charUnderCursor;
    }
    if (Cursor::pos.collidesWith({19, 0}))
        return 'x';
    if (Cursor::pos.collidesWith({19, 1}))
        return RenderSubmit() ? confirm_charcode : ' ';
    if (Cursor::pos.collidesWith({19, 2}))
        return upArrowChar;
    if (Cursor::pos.collidesWith({19, 3}))
        return downArrowChar;
    return '-';
}

void AppRender::UpdateView()
{
    for (int y = 0; y < 3; y++)
    {
        for (int x = 0; x < 19; x++)
        {
            if (!Cursor::pos.collidesWith({x, y + 1}))
            {
                lcd.setCursor(x, y + 1);
                lcd.write(appScreenData[x][y]);
            }
        }
    }
}

void AppRender::UpdateLoop(Pos pos, byte)
{
    UpdateCurrentApp();
    lcd.home();
    for (int i = 0; i < 16; i++)
    {
        if (!Cursor::pos.collidesWith({i, 0}))
        {
            lcd.setCursor(i, 0);
            lcd.write(appTitle[i]);
        }
    }
    if (!Cursor::pos.collidesWith({16, 0}))
        lcd.setCursor(16, 0), lcd.write(' ');
    if (!Cursor::pos.collidesWith({17, 0}))
        lcd.setCursor(17, 0), lcd.write(GetCursorPosChar());
    if (!Cursor::pos.collidesWith({18, 0}))
        lcd.setCursor(18, 0), lcd.write(' ');
    if (!Cursor::pos.collidesWith({19, 0}))
        lcd.setCursor(19, 0), lcd.write('x');

    UpdateView();
    lcd.setCursor(19, 1);
    lcd.write(RenderSubmit() ? confirm_charcode : ' ');
    lcd.setCursor(19, 2);
    lcd.write(upArrowChar);
    lcd.setCursor(19, 3);
    lcd.write(downArrowChar);
}

void AppRender::Update()
{
    Pos cursorPos = Cursor::Get<byte>(UpdateLoop, 0);
    while (digitalRead(swPin) == LOW)
        ;

    if (cursorPos.x < 19 && cursorPos.y > 0)
    {
        ClickCurrentApp(&cursorPos);
    }
    else if (cursorPos.collidesWith({19, 0}))
    {
        ExitCurrentApp();
    }
    else if (cursorPos.collidesWith({19, 1}))
    {
        SubmitCurrentApp();
    }
    else if (cursorPos.collidesWith({19, 2}))
    {
        ScrollCurrentApp(1);
    }
    else if (cursorPos.collidesWith({19, 3}))
    {
        ScrollCurrentApp(-1);
    }
}

#endif

//filepath: apps\browser\index.hpp
#ifndef APPS_BROWSER_INDEX_HPP
#define APPS_BROWSER_INDEX_HPP

#include "../../utils/structs/pos.hpp"
#include "../../globals.hpp"
#include "../../utils/structs/text.hpp"
#include "../../utils/structs/clickable.hpp"
#include "../../utils/structs/input.hpp"
#include "../../utils/structs/stored-map.hpp"

enum AppPage
{
    Home,
    Settings,
    Search,
    History,
    Bookmarks,
};

namespace BrowserApp
{
    Text noWifiText(1, 1, "No Wifi");
    Btn connectToWifiButton = Button(2, 0, "Connect"); // Fixed typo here
    Input goToViewInput(1, 0, 19, "website ip:port...", "192.168.178.33");

    namespace State
    {
        AppPage appPage = Home; // Use 'appPage' not 'appState'
        String currentWebsite = "";
        FlashHashMap webSiteData("web-site-data");
    }

    // helpers
    bool WaitForConnected();

    // functions
    void Update();
    void Scroll(signed char direction);
    void OnExit();
    void OnClick(Pos clickPos);
};

#include "./update.hpp"
#include "./scroll.hpp"
#include "./on-exit.hpp"
#include "./on-click.hpp"

#endif


//filepath: apps\browser\on-click.hpp
#ifndef APPS_BROWSER_ON_CLICK_HPP
#define APPS_BROWSER_ON_CLICK_HPP

#include "../../globals.hpp"
#include "../../app-renderer.hpp"
#include "../../utils/structs/pos.hpp"
#include "./index.hpp"

void BrowserApp::OnClick(Pos clickPos)
{
    if (WiFi.status() != WL_CONNECTED) // Fixed typo here
    {
        if (connectToWifiButton.collidesWith(clickPos))
            AppRender::appOpened = "wifi";

        return;
    }

    // With Internet

    goToViewInput.OnClick(clickPos);
}

#endif

//filepath: apps\browser\on-exit.hpp
#ifndef APPS_BROWSER_ON_EXIT_HPP
#define APPS_BROWSER_ON_EXIT_HPP

#include "../../globals.hpp"
#include "./index.hpp"

void BrowserApp::OnExit()
{
}

#endif

//filepath: apps\browser\scroll.hpp
#ifndef APPS_BROWSER_SCROLL_HPP
#define APPS_BROWSER_SCROLL_HPP

#include "../../globals.hpp"
#include "./index.hpp"

void BrowserApp::Scroll(signed char direction)
{
    SetAppTitle("Browser", 7);
}

#endif

//filepath: apps\browser\update.hpp
#ifndef APPS_BROWSER_UPDATE_HPP
#define APPS_BROWSER_UPDATE_HPP

#include "../../globals.hpp"
#include "./index.hpp"

bool BrowserApp::WaitForConnected()
{
    static bool wasConnected;
    if (WiFi.status() != WL_CONNECTED)
    {
        // Render offline UI
        noWifiText.Draw();
        connectToWifiButton.Draw(); // Fixed typo here
        wasConnected = WiFi.status() != WL_CONNECTED;
        return false;
    }

    if (!wasConnected)
    {
        ClearAppScreen();
    }

    return true;
}

void BrowserApp::Update()
{
    SetAppTitle("Browser", 7);

    if (!WaitForConnected())
        return;

    if (State::appPage == Home) // Fixed appState to appPage here
    {
        goToViewInput.Draw();
    }
}

#endif

//filepath: apps\clock\index.hpp
#ifndef APPS_CLOCK_INDEX_HPP
#define APPS_CLOCK_INDEX_HPP

#include "../../utils/structs/pos.hpp"
#include "../../globals.hpp"
#include "../../time.hpp"

namespace ClockApp
{
    void Update()
    {
        SetAppTitle("Clock", 5);
    }

    void Scroll(signed char direction)
    {
    }

    void OnClick(Pos clickPos)
    {
    }

    void Submit()
    {
    }
};

#endif

//filepath: apps\create-account\index.hpp
#ifndef APPS_CREATE_ACCOUNT_INDEX_HPP
#define APPS_CREATE_ACCOUNT_INDEX_HPP

#include "../../utils/structs/draw-keybord-meta-data.hpp"
#include "../../globals.hpp"
#include "../../utils/index.hpp"
#include "../../read/index.hpp"
#include "../../data/index.hpp"

namespace CreateAccountApp
{
    void Create()
    {
        CURSOR_OFFSET = 6;
        // create new account ui
        lcd.clear();
        lcd.setCursor(1, 0);
        lcd.print("create new account");
        lcd.setCursor(3, 1);
        lcd.print("input password");
        lcd.setCursor(2, 3);
        lcd.print("(press joystick)");

        // get the password
    getPassword:
        utils::waitForRelease();
        lcd.setCursor(5, 1);
        lcd.print("password:");
        lcd.setCursor(0, 2);
        lcd.print("(6 characters long)");
        utils::waitForRelease();
        auto passwordStringPtr = new String("");
        String password = *input::ReadString(DrawKeyBoardMetaData{0, passwordStringPtr});
        if (password.length() != 6) // check length
        {
            lcd.clear();
            lcd.setCursor(1, 1);
            lcd.print("Password isn't 6");
            lcd.setCursor(2, 2);
            lcd.print("characters long");
            goto getPassword;
        }
        // rewrite password
        lcd.clear();
        lcd.setCursor(2, 1);
        lcd.print("rewrite password");
        utils::waitForRelease();
        auto passwordStringPtr2 = new String("");
        String password2 = *input::ReadString(DrawKeyBoardMetaData{0, passwordStringPtr2});

        // if they arent the same retry
        if (password != password2)
        {
            lcd.clear();
            lcd.setCursor(1, 1);
            lcd.print("Passwords aren't");
            lcd.setCursor(5, 2);
            lcd.print("the same");
            goto getPassword;
        }

        data::auth::createAccount(&password);
        delete passwordStringPtr;
        delete passwordStringPtr2;
    }
};

#endif

//filepath: apps\eeprom-editor\index.hpp
#ifndef APPS_EEPROM_EDITOR_INDEX_HPP
#define APPS_EEPROM_EDITOR_INDEX_HPP

#include "../../utils/structs/pos.hpp"
#include "../../globals.hpp"
#include "../../app-renderer.hpp"
#include "../../data/index.hpp"
#include "../../read/index.hpp"

namespace EEPROMEditor
{
    int pos = 8;

    void Scroll(signed char direction)
    {
        if (direction > 0 && pos < EEPROM_SIZE)
        {
            pos++;
        }
        else if (direction < 0 && pos > 0)
        {
            pos--;
        }
    }

    void Update()
    {
        SetAppTitle("EEPROM Editor", 13);

        // render the data on the top line
        for (int i = 0; i < 19; i++)
        {
            int readPos = pos + i - 10;

            if (readPos < 0 || readPos > EEPROM_SIZE)
            {
                appScreenData[i][1] = ' ';
                continue;
            }

            appScreenData[i][1] = data::readFromEEPROM(readPos);
        }

        // cursor
        appScreenData[10][2] = '^';

        // clear number digits
        appScreenData[9][0] = ' ';
        appScreenData[10][0] = ' ';
        appScreenData[11][0] = ' ';

        // Render pos number
        if (pos < 10)
        {
            appScreenData[11][0] = 48 + pos;
        }
        else if (pos < 100)
        {
            appScreenData[10][0] = 48 + (pos / 10); // Tens place
            appScreenData[11][0] = 48 + (pos % 10); // Units place
        }
        else if (pos < 1000)
        {
            appScreenData[9][0] = 48 + ((pos / 100));      // Hundreds place
            appScreenData[10][0] = 48 + ((pos / 10) % 10); // Tens place
            appScreenData[11][0] = 48 + (pos % 10);        // Units place
        }
    }

    void Submit()
    {
        lcd.clear();

        // get & write the new number
        data::writeToEEPROM(pos, input::getByte("new val:", data::readFromEEPROM(pos)));

        lcd.clear();
    }
};

#endif

//filepath: apps\flash-light\index.hpp
#ifndef APPS_FLASH_LIGHT_INDEX_HPP
#define APPS_FLASH_LIGHT_INDEX_HPP

#include "../../utils/structs/pos.hpp"
#include "../../utils/structs/clickable.hpp"
#include "../../globals.hpp"

namespace FlashLightApp
{
  Clickable toggleButton{2, 7, 11, "ON", 2};
  bool isOn = false;

  void Update()
  {
    SetAppTitle("Flash Light", 11);
    for (byte i = 0; i < 11; i++)
    {
      appScreenData[i + 4][1] = "Flash Light"[i];
    }
    toggleButton.Draw();
  }

  void UpdateUI()
  {
    // set ui
    if (isOn)
    {
      toggleButton.text = "OFF";
      toggleButton.end = 12;
      toggleButton.stringLength = 3;
    }
    else
    {
      toggleButton.text = "ON";
      toggleButton.end = 11;
      toggleButton.stringLength = 2;
      appScreenData[11][2] = ' ';
    }
  }

  void Toggle()
  {
    // toggle
    isOn = !isOn;
    digitalWrite(ledPin, isOn ? HIGH : LOW);
    UpdateUI();
  }

  void Submit()
  {
    Toggle();
  }

  void OnClick(Pos pos)
  {
    if (toggleButton.collidesWith(pos))
      Toggle();
  }
}

#endif

//filepath: apps\home\doc.cpp
/*
 * HomeApp Module
 *
 * This module defines the functionality of the "Home" app in the system,
 * allowing users to view and manage a list of applications (apps) and
 * external links, known as HomeLinks, which appear on the home screen.
 *
 * Main components:
 *
 * - `HomeLink` struct: Represents an individual link or app on the home screen,
 *   storing details like name, app ID, a flag indicating whether itâ€™s an app
 *   (`isApp`), and any optional start arguments.
 *
 * - `homeLinks` vector: Stores all HomeLink instances, including:
 *   1. **Default Apps**: Predefined apps that are always available, such as
 *      "Wifi", "Browser", and "Clock". These default apps are initialized
 *      within the `Init` function and are marked with `isApp = true`.
 *   2. **User-Defined Links**: Additional links, which can be created by users
 *      and are stored in `/app-links.data`. These links are loaded on startup
 *      if they are unique and marked with `isApp = false`.
 *
 * - `appSelect` object: Provides selection and scrolling functionality for
 *   navigating the `homeLinks`.
 *
 * - Core Functions:
 *   - `AddHomeLink`: Adds a new HomeLink if its name is unique, saving it to
 *     both memory and a file (`/app-links.data`). The link's name, app ID,
 *     and any start argument are stored in `base64` encoded format to ensure
 *     safe and consistent file storage.
 *   - `RemoveHomeLink`: Removes a specified HomeLink, updating the list in
 *     memory and rewriting the file without the deleted link.
 *   - `Init`: Initializes the default apps and loads additional user-defined
 *     links from the `/app-links.data` file, decoding `base64` values to retrieve
 *     the original names, app IDs, and arguments. This ensures all links are
 *     unique in `homeLinks`.
 *   - `Update`, `Scroll`, `SwitchApp`: Handle updating the display, scrolling
 *     through the links, and switching to a selected app when clicked.
 *
 * - File Persistence and `base64` Encoding: Uses `LittleFS` to store
 *   additional HomeLinks persistently, encoding each link's properties
 *   (name, app ID, and start arguments) in `base64` format within `/app-links.data`.
 *   This ensures data integrity and compatibility across different devices.
 *
 * Organization of `homeLinks`:
 *   - The `homeLinks` vector maintains a structured order by first adding
 *     predefined default apps during initialization, followed by user-defined
 *     links from the filesystem.
 *   - Each link is checked for uniqueness using `IsHomeLinkUnique` to avoid
 *     duplicate entries, and entries are loaded from `/app-links.data` only
 *     if not already present.
 */
// author chatgpt (i havent rode it)

//filepath: apps\home\index.hpp
#ifndef APPS_HOME_HPP
#define APPS_HOME_HPP

#include "../../globals.hpp"
#include "../../cursor.hpp"
#include "../../auth.hpp"
#include "../../utils/structs/pos.hpp"
#include "../../utils/structs/select.hpp"
#include "../../app-renderer.hpp"

// apps
#include "../create-account/index.hpp"

struct HomeLink
{
    String name;
    String appId;
    bool isApp;
    String startArgument;

    HomeLink(String _name, String _appId, bool _isApp = true, String _startArgument = "")
        : name(_name), appId(_appId), isApp(_isApp), startArgument(_startArgument) {}
};

namespace HomeApp
{
    String state;
    std::vector<HomeLink> homeLinks;
    Select appSelect{nullptr, 0, 1};

    void SetAppSelect()
    {
        if (appSelect.options != nullptr)
        {
            delete[] appSelect.options;
        }

        appSelect.options = new String[homeLinks.size()];
        for (size_t i = 0; i < homeLinks.size(); i++)
        {
            appSelect.options[i] = homeLinks[i].name;
        }
        appSelect.optionsLength = homeLinks.size();
    }

    String EscapeString(const String &input)
    {
        String escaped = input;
        escaped.replace("\\", "\\\\"); // Escape backslashes
        escaped.replace("\n", "\\n");  // Escape newlines
        escaped.replace("|", "\\|");   // Escape pipes
        return escaped;
    }

    String DeescapeString(const String &input)
    {
        String deescaped = input;
        deescaped.replace("\\n", "\n");  // Deescape newlines
        deescaped.replace("\\|", "|");   // Deescape pipes
        deescaped.replace("\\\\", "\\"); // Deescape backslashes
        return deescaped;
    }

    bool IsHomeLinkUnique(const String &name)
    {
        for (const auto &link : homeLinks)
        {
            if (link.name == name)
            {
                return false;
            }
        }
        return true;
    }

    void LoadHomeLinksFromFile()
    {
        File file = LittleFS.open("/app-links.data", "r");
        if (!file)
        {
            Serial.println("Failed to open app-links.data");
            return;
        }

        while (file.available())
        {
            String line = file.readStringUntil('\n');
            line.replace("|", "\n"); // Convert the separator to a newline for processing

            String parts[3];
            int count = 0;

            for (int i = 0; i < line.length(); i++)
            {
                if (line[i] == '\n' || i == line.length() - 1)
                {
                    if (i == line.length() - 1)
                    {
                        parts[count++] += line[i];
                    }
                    count++;
                    if (count >= 3)
                        break;
                }
                else
                {
                    parts[count] += line[i];
                }
            }

            if (count == 3)
            {
                String name = DeescapeString(parts[0]);
                String appId = DeescapeString(parts[1]);
                String startArg = DeescapeString(parts[2]);

                if (IsHomeLinkUnique(name))
                {
                    homeLinks.push_back(HomeLink(name, appId, true, startArg));
                }
            }
        }

        file.close();
    }

    void Init()
    {
        // Load default home links
        homeLinks = {
            HomeLink("Wifi", "wifi"),
            HomeLink("Browser", "browser"),
            HomeLink("Clock", "clock"),
            HomeLink("Flash Light", "flash-light"),
            HomeLink("Pin Menager", "pin-menager"),
            HomeLink("EEPROM Editor", "eeprom-editor"),
            HomeLink("Memory Editor", "memory-editor"),
            HomeLink("Login", "login"),
            HomeLink("Create Account", "create-account"),
        };

        // Load links from file
        LoadHomeLinksFromFile();

        // Update appSelect after loading
        SetAppSelect();
    }

    void AddHomeLink(const HomeLink &link)
    {
        if (IsHomeLinkUnique(link.name))
        {
            homeLinks.push_back(link);
            SetAppSelect();
            // Append to the file
            File file = LittleFS.open("/app-links.data", "a");
            if (file)
            {
                file.print(EscapeString(link.name) + "|" + EscapeString(link.appId) + "|" + EscapeString(link.startArgument) + "\n");
                file.close();
            }
        }
    }

    void RemoveHomeLink(const String &name)
    {
        homeLinks.erase(
            std::remove_if(homeLinks.begin(), homeLinks.end(),
                           [&](const HomeLink &link)
                           { return link.name == name; }),
            homeLinks.end());

        SetAppSelect();
        // Update the file by rewriting all home links
        File file = LittleFS.open("/app-links.data", "w");
        if (file)
        {
            for (const auto &link : homeLinks)
            {
                file.print(EscapeString(link.name) + "|" + EscapeString(link.appId) + "|" + EscapeString(link.startArgument) + "\n");
            }
            file.close();
        }
    }

    void Update()
    {
        SetAppTitle("Home", 4);
        appSelect.Update();
    }

    void Scroll(signed char direction)
    {
        appSelect.Scroll(direction);
    }

    void SwitchApp()
    {
        int clickedApp = appSelect.OnClick();
        ClearAppScreen();

        const HomeLink &selectedLink = homeLinks[clickedApp];

        if (selectedLink.name == "Create Account")
        {
            isLoggedIn = false;
            CreateAccountApp::Create();
        }
        else
        {
            AppRender::appOpened = selectedLink.appId;

            if (selectedLink.isApp && registeredApps[AppRender::appOpened].Start)
            {
                registeredApps[AppRender::appOpened].Start(selectedLink.startArgument);
            }
        }
    }

    void OnClick(Pos)
    {
        SwitchApp();
    }

    void Submit()
    {
        SwitchApp();
    }
};

#endif

//filepath: apps\login\index.hpp
#ifndef APPS_LOGIN_HPP
#define APPS_LOGIN_HPP

#include "../../globals.hpp"
#include "../../config.hpp"
#include "../../read/index.hpp"
#include "../../utils/structs/pos.hpp"
#include "../../utils/structs/clickable.hpp"
#include "../create-account/index.hpp"

namespace LoginApp
{
    String state;
    bool createAccountPage = false;
    Clickable passwordInput{1, 5, 15, "password", 8};
    Clickable createNewAccountButton{2, 3, 16, "new account", 11};

    void Update()
    {
        SetAppTitle("login", 5);

        if (createAccountPage)
        {
            for (int i = 0; i < 10; i++)
            {
                appScreenData[i + 5][0] = ("You forgot")[i];
            }
            for (int i = 0; i < 15; i++)
            {
                appScreenData[i + 2][1] = ("your password?!")[i];
            }
            createNewAccountButton.Draw();
        }
        else
        {
            passwordInput.Draw();
        }
    }

    void Scroll(signed char direction)
    {
        ClearAppScreen();
        createAccountPage = !createAccountPage;
    }

    void CheckPasswordInputClickedAndLogin(Pos clickPos)
    {
        // password button clicked
        if (passwordInput.collidesWith(clickPos))
        {
            CURSOR_OFFSET = 6;
            String *defaultInputStringPtr = new String("");
// no password in debug mode
#if IS_IN_DEBUG_LOGGED_IN
            if (true)
#else
            // get password input
            auto result = input::ReadString(DrawKeyBoardMetaData{0, defaultInputStringPtr})->c_str();
            // is right password
            if (data::auth::isRightPassword(result))
#endif
            {
                isLoggedIn = true;
                lcd.clear();
                lcd.setCursor(5, 1);
                lcd.print("Logged in");
                delay(1000);
                lcd.clear();
            }
            else
            {
                lcd.clear();
                lcd.setCursor(3, 1);
                lcd.print("wrong password");
                delay(1000);
                lcd.clear();
            }

            delete defaultInputStringPtr;
        }
    }

    void CheckChangePasswordButton(Pos clickPos)
    {
        // password button clicked
        if (createNewAccountButton.collidesWith(clickPos))
        {
            CreateAccountApp::Create();
        }
    }

    void OnClick(Pos clickPos)
    {
        if (createAccountPage)
            CheckChangePasswordButton(clickPos);
        else
            CheckPasswordInputClickedAndLogin(clickPos);
    }
};

#endif

//filepath: apps\memory-editor\index.hpp
#ifndef APPS_EEPROM_MEMORY_EDITOR_HPP
#define APPS_EEPROM_MEMORY_EDITOR_HPP

#include "../../utils/structs/pos.hpp"
#include "../../globals.hpp"
#include "../../app-renderer.hpp"
#include "../../read/index.hpp"

namespace MemoryEditor
{
    int pos = 0;

    void Scroll(signed char direction)
    {
        if (direction > 0 && pos < MAX_MEM_PTR)
        {
            pos++;
        }
        else if (direction < 0 && pos > 0)
        {
            pos--;
        }
    }

    void Update()
    {
        SetAppTitle("Memory Editor", 13);

        // render the data on the top line
        for (int i = 0; i < 19; i++)
        {
            int readPos = pos + i - 10;

            if (readPos < 0 || readPos > MAX_MEM_PTR)
            {
                appScreenData[i][1] = ' ';
                continue;
            }

            appScreenData[i][1] = *(byte *)readPos;
        }

        // cursor
        appScreenData[10][2] = '^';

        // clear number digits
        appScreenData[9][0] = ' ';
        appScreenData[10][0] = ' ';
        appScreenData[11][0] = ' ';

        // Render pos number
        if (pos < 10)
        {
            appScreenData[11][0] = 48 + pos;
        }
        else if (pos < 100)
        {
            appScreenData[10][0] = 48 + (pos / 10); // Tens place
            appScreenData[11][0] = 48 + (pos % 10); // Units place
        }
        else if (pos < 1000)
        {
            appScreenData[9][0] = 48 + ((pos / 100));      // Hundreds place
            appScreenData[10][0] = 48 + ((pos / 10) % 10); // Tens place
            appScreenData[11][0] = 48 + (pos % 10);        // Units place
        }
        else if (pos < 10000)
        {
            appScreenData[8][0] = 48 + ((pos / 1000));      // Tousends place
            appScreenData[9][0] = 48 + ((pos / 100) % 10); // Hundreds place
            appScreenData[10][0] = 48 + ((pos / 10) % 10); // Tens place
            appScreenData[11][0] = 48 + (pos % 10);        // Units place
        }
    }

    void Submit()
    {
        lcd.clear();

        // write in memory
        byte *memPtr = (byte *)pos;
        *memPtr = pos, input::getByte("new val:", EEPROM.read(*(byte *)pos));

        lcd.clear();
    }
};

#endif

//filepath: apps\pin-menager\index.hpp
#ifndef APPS_PIN_MENAGERINDEX_HPP
#define APPS_PIN_MENAGERINDEX_HPP

#include "../../utils/structs/pos.hpp"
#include "../../utils/structs/clickable.hpp"
#include "../../globals.hpp"

namespace PinMengerApp
{
    void Update()
    {
        SetAppTitle("Pin Menager", 11);
    }

    void OnClick(Pos)
    {
    }

    void Scroll(signed char)
    {
    }

    void Submit()
    {
    }
}

#endif

//filepath: apps\wifi\connect-to-wifi.hpp
#ifndef APPS_WIFI_CONNECT_TO_WIFI_HPP
#define APPS_WIFI_CONNECT_TO_WIFI_HPP

#include "../../globals.hpp"

#include "./index.hpp"
#include "../../utils/structs/stored-map.hpp"

FlashHashMap wifisConnected("wifis");

void WifiApp::ConnectToWifi()
{
    try
    {
        // Clear the screen and display connecting message
        lcd.clear();
        lcd.home();
        lcd.print("Connecting to WiFi:");
        lcd.setCursor(0, 2);
        lcd.print(utils::setStringSize(WiFi.SSID(wifiIndex), 20)); // Display selected network
        lcd.setCursor(1, 3);
        lcd.print("<<exit | connect>>");

        // Wait for joystick input (guard clause: exit on left movement)
        while (utils::normalizeJoystick(xPin) == 0)
        {
        }

        if (utils::normalizeJoystick(xPin) < 0)
        {
            // Joystick moved left, exit early
            lcd.clear();
            lcd.print("Aborted!");
            delay(1000);
            wifiIndex = -2;
            state = 0;
            return;
        }

        // Wait for joystick release
        while (utils::normalizeJoystick(xPin) != 0)
        {
        }

        // Check if the network is open (no password required)
        bool isOpenNetwork = (WiFi.encryptionType(wifiIndex) == WIFI_AUTH_OPEN);

        String defaultPassword = wifisConnected.get(WiFi.SSID(wifiIndex)); // Optional default password
        String *password;
        // Guard clause: skip password input for open networks
        if (isOpenNetwork)
        {
            lcd.clear();
            lcd.print("Connecting to open network...");
            WiFi.begin(WiFi.SSID(wifiIndex)); // Connect without password
        }
        else
        {
            // Prompt for password if needed
            lcd.clear();
            lcd.setCursor(0, 0);
            lcd.print("Enter password:");
            delay(1000);

            // get password length
            CURSOR_OFFSET = defaultPassword.length() > 15 || defaultPassword.length() < 8 ? 15 : defaultPassword.length();
            // metadata
            password = input::ReadString({defaultPassword.length(), &defaultPassword}); // Read user input

            // Guard clause: check if the password is null or empty
            if (password == nullptr || password->length() == 0)
            {
                lcd.clear();
                lcd.print("Invalid Password!");
                delay(2000);
                wifiIndex = -2;
                state = 0;
                return; // Early exit if no password is provided
            }

            lcd.clear();
            lcd.setCursor(0, 1);
            lcd.print("Connecting...");

            WiFi.begin(WiFi.SSID(wifiIndex), *password); // Connect with password
        }

        // Guard clause: handle timeout or failed connection
        unsigned long startTime = millis();
        const unsigned long timeout = 10000; // 10-second timeout

        while (WiFi.status() != WL_CONNECTED)
        {
            if (millis() - startTime > timeout)
            {
                lcd.clear();
                lcd.setCursor(0, 1);
                lcd.print("Connection Failed!");
                if (!isOpenNetwork)
                {
                    lcd.setCursor(0, 2);
                    lcd.print("Try to rewrite password!");
                }
                delay(2000);    // Display failure message
                wifiIndex = -2; // Reset selection
                state = 0;
                return; // Early exit on connection failure
            }
        }

        // Success message
        lcd.clear();
        lcd.setCursor(0, 1);
        lcd.print("Connected!");
        lcd.setCursor(0, 2);
        lcd.print("IP: ");
        lcd.print(WiFi.localIP()); // Show IP address
        delay(2000);

        // store wifi passwor
        wifisConnected.set(WiFi.SSID(wifiIndex), isOpenNetwork ? "no pasword" : *password);

        // Reset state for further actions
        wifiIndex = -2;
        state = 0;
    }
    catch (const std::exception &e)
    {
        // Handle any unexpected errors
        lcd.clear();
        lcd.setCursor(0, 1);
        lcd.print("Error occurred:");
        lcd.setCursor(0, 2);
        lcd.print(e.what()); // Display error message
        delay(3000);         // Display error for 3 seconds
        wifiIndex = -2;
        state = 0;
    }
    catch (...)
    {
        // Catch any other unhandled errors
        lcd.clear();
        lcd.setCursor(0, 1);
        lcd.print("Unknown error!");
        delay(3000); // Display generic error
        wifiIndex = -2;
        state = 0;
    }
}

#endif

//filepath: apps\wifi\fast-connect.hpp
#ifndef APPS_WIFI_FAST_CONNECT_HPP
#define APPS_WIFI_FAST_CONNECT_HPP

#include "./connect-to-wifi.hpp"
#include "./index.hpp"

void WifiApp::FastConnect()
{
    try
    {
        ClearAppScreen();                 // Clear the display before scanning
        Text(1, 1, "Scanning...").Draw(); // Display scanning message
        AppRender::UpdateView();          // Update the screen

        // Scan for available WiFi networks
        int wifiCount = WifiScanStart(true, true);
        if (wifiCount < 1)
        {
            ClearAppScreen();
            Text(1, 1, "No WiFi").Draw();
            Text(2, 1, "networks found").Draw();
            AppRender::UpdateView();
            delay(1000);
            return;
        }

        int wifiIndex = 0;
        bool connectionAttempted = false;
        bool isOpenNetwork = false; // Declare isOpenNetwork here so it can be used later

        // Loop through WiFi networks for selection with the joystick
        while (wifiIndex < wifiCount && wifiIndex > -1)
        {
            // Get current WiFi network's SSID and encryption type
            String ssid = WiFi.SSID(wifiIndex);
            isOpenNetwork = (WiFi.encryptionType(wifiIndex) == WIFI_AUTH_OPEN); // Assign the value here

            // Check if the network is either open or its SSID is in wifisConnected
            if (isOpenNetwork || wifisConnected.has(ssid))
            {
                // Display the current WiFi network name
                lcd.clear();
                lcd.setCursor(0, 1);
                lcd.print(utils::setStringSize(ssid, 20));
                lcd.setCursor(0, 2);
                lcd.print("<<next  |  connect>>");

                // Wait for joystick input (left to skip, right to select, or stay idle)
                int swipeDirection = 0;
                // wait for joystick input (left to skip, right to select, or stay idle)
                while ((swipeDirection = utils::normalizeJoystick(xPin)) == 0)
                {
                }
                lcd.clear();
                lcd.setCursor(5, 1);
                lcd.print(swipeDirection < 0 ? "next" : "selected");
                lcd.clear();
                // wait for no movement
                while (utils::normalizeJoystick(xPin) != 0)
                {
                }

                if (swipeDirection < 0)
                {
                    // Move to the next network
                    wifiIndex++;
                    // all networks shown
                    if (wifiIndex == wifiCount)
                    {
                        lcd.clear();
                        lcd.setCursor(3, 1);
                        lcd.print("not connected");
                        delay(1000);
                        lcd.clear();
                        return;
                    }
                }
                else
                {
                    // User selected this network
                    connectionAttempted = true;
                    break;
                }
            }
            else
            {
                // If the network is not open and not in wifisConnected, skip to the next
                wifiIndex++;
                if (wifiIndex >= wifiCount)
                    wifiIndex = 0; // Loop back to first network
            }
        }

        if (!connectionAttempted)
            return; // Exit if no network was selected

        // Now, attempt to connect to the selected network
        String password = wifisConnected.get(WiFi.SSID(wifiIndex)); // Get password (if any)

        // Attempt to connect: open network (no password) or known network with stored password
        if (isOpenNetwork)
        {
            WiFi.begin(WiFi.SSID(wifiIndex)); // Open network, no password
        }
        else
        {
            WiFi.begin(WiFi.SSID(wifiIndex), password); // Secured network with password
        }

        // Guard clause: handle timeout or failed connection
        unsigned long startTime = millis();
        const unsigned long timeout = 10000; // 10-second timeout

        while (WiFi.status() != WL_CONNECTED)
        {
            if (millis() - startTime > timeout)
            {
                lcd.clear();
                lcd.setCursor(0, 1);
                lcd.print("Connection Failed!");
                delay(2000);    // Display failure message
                wifiIndex = -2; // Reset selection
                state = 0;
                return; // Early exit on connection failure
            }
        }

        // Connection success message
        lcd.clear();
        lcd.setCursor(2, 1);
        lcd.print("Connected!");
        lcd.setCursor(0, 2);
        lcd.print(utils::setStringSize(WiFi.SSID(wifiIndex), 20));
        lcd.setCursor(0, 3);
        lcd.print("IP: ");
        lcd.print(utils::setStringSize(WiFi.localIP().toString(), 16)); // Show IP address
        delay(2000);

        // Reset state for further actions
        wifiIndex = -2;
        state = 0;
    }
    catch (const std::exception &e)
    {
        // Handle any unexpected errors
        lcd.clear();
        lcd.setCursor(0, 1);
        lcd.print("Error occurred:");
        lcd.setCursor(0, 2);
        lcd.print(e.what()); // Display error message
        delay(3000);         // Display error for 3 seconds
        wifiIndex = -2;
        state = 0;
    }
    catch (...)
    {
        // Catch any other unhandled errors
        lcd.clear();
        lcd.setCursor(0, 1);
        lcd.print("Unknown error!");
        delay(3000); // Display generic error
        wifiIndex = -2;
        state = 0;
    }
}

#endif // APPS_WIFI_FAST_CONNECT_HPP

//filepath: apps\wifi\index.hpp
#ifndef APPS_WIFI_INDEX_HPP
#define APPS_WIFI_INDEX_HPP

#include "../../utils/structs/pos.hpp"
#include "../../utils/structs/clickable.hpp"
#include "../../utils/structs/text.hpp"
#include "../../utils/structs/select.hpp"
#include "../../globals.hpp"
#include "../../utils/index.hpp"
#include "../../read/index.hpp"
#include "../../cursor.hpp"
#include "../../app-renderer.hpp"
#include "../../wifi/get-network-list.hpp"

namespace WifiApp
{
    Select *wifiSelect = nullptr; // Dynamically allocated Select object for WiFi networks
    // home page
    Clickable startScanButton{1, 1, 11, "WifiScan", 8}; // Start WiFi scan button
    Clickable fastConnectButton{2, 1, 10, "Connect", 7};
    // wifi page
    Clickable connectToWifiButton{1, 1, 10, "Connect", 7}; // Connect button
    Clickable abortWifiButton{2, 1, 8, "Abort", 5};        // Abort button (Corrected label)

    byte state = 0;
    byte count = 50; // Counter to manage scanning delay and updates
    int wifiIndex = -2;

    void ClearWifiSelect()
    {
        if (wifiSelect != nullptr)
        {
            delete[] wifiSelect->options; // Free memory allocated for options
            delete wifiSelect;            // Free the wifiSelect itself
            wifiSelect = nullptr;         // Avoid dangling pointer
        }
    }

    void Update();

    void Submit()
    {
        if (state == 1 && wifiSelect != nullptr)
        {
            wifiSelect->OnClick(); // Handle the submit event for the selected network
        }
    }

    void Scroll(signed char direction)
    {
        if (state == 1 && wifiSelect != nullptr)
        {
            wifiSelect->Scroll(direction); // Allow scrolling through the network list
        }
    }

    void ConnectToWifi();
    void FastConnect();

    void OnClick(Pos pos)
    {
        if (wifiIndex > -1)
        {
            if (connectToWifiButton.collidesWith(pos))
            {
                ConnectToWifi();
            }
            else if (abortWifiButton.collidesWith(pos))
            {
                wifiIndex = -2;
                state = 0;
            }
        }
        else if (state == 0)
        {
            if (startScanButton.collidesWith(pos))
            {
                state = 1;        // Change state to scanning
                ClearAppScreen(); // Clear the screen before scanning
            }
            else if (fastConnectButton.collidesWith(pos))
            {
                FastConnect();
                state = 0; // Change state to scanning
                ClearAppScreen();
            }
        }
        else if (state == 1 && wifiSelect != nullptr)
        {
            wifiIndex = wifiSelect->OnClick(); // Handle click events for network selection
        }
    }
}

#include "./connect-to-wifi.hpp"
#include "./fast-connect.hpp"
#include "./update.hpp"

#endif


//filepath: apps\wifi\update.hpp
#ifndef APPS_WIFI_UPDATE_HPP
#define APPS_WIFI_UPDATE_HPP

#include "./index.hpp"

void WifiApp::Update()
{
    try
    {
        // set title to "Wifi   (x if offline or y if online)"
        char title[11]; // 10 characters + null terminator
        strcpy(title, WiFi.status() == WL_CONNECTED ? "WiFi   (y)" : "WiFi   (x)");
        SetAppTitle(title, 10);

        if (wifiIndex == -1)
        {
            ClearAppScreen();
            Text(1, 1, "No Network Selected").Draw();
            AppRender::UpdateView();
            delay(1000);
            wifiIndex = -2;
            state = 0;
        }
        else if (wifiIndex > -1)
        {
            ClearAppScreen();
            Text(0, 0, utils::setStringSize(WiFi.SSID(wifiIndex), 19)).Draw();
            connectToWifiButton.Draw();
            abortWifiButton.Draw();
        }
        else if (state == 0)
        {
            ClearAppScreen();
            // Render SSID or "No Wifi"
            Text(0, 1, WiFi.status() == WL_CONNECTED ? utils::setStringSize(WiFi.SSID(), 17).c_str() : "No Wifi").Draw();
            // Display the button for initiating WiFi scanning
            startScanButton.Draw();
            // Display the button for initiating WiFi scanning
            fastConnectButton.Draw();
        }
        else if (state == 1)
        {
            if (count == 50)
            {
                ClearAppScreen();                 // Clear the display before scanning
                Text(1, 1, "Scanning...").Draw(); // Display searching message
                AppRender::UpdateView();          // Update the screen

                // Scan for available WiFi networks
                int wifiCount = WifiScanStart(true, true);

                if (wifiCount > 0) // If networks are found
                {
                    // Display processing message
                    Text(1, 1, "Processing...").Draw();
                    AppRender::UpdateView();

                    ClearWifiSelect(); // Free any previously allocated wifiSelect

                    wifiSelect = GetWifiNetworkSelect(wifiCount); // Get the new list of WiFi networks
                    if (wifiSelect != nullptr)
                    {
                        wifiSelect->Update(); // Update the selection widget
                    }
                    else
                    {
                        // Handle allocation failure
                        Text(1, 1, "Failed to allocate memory").Draw();
                        AppRender::UpdateView();
                        delay(1000);
                        state = 0; // Reset state on failure
                    }
                }
                else // If no networks were found
                {
                    ClearAppScreen();
                    Text(1, 1, "0 Networks Found").Draw();
                    AppRender::UpdateView();
                    delay(1000);
                    ClearAppScreen();
                    state = 0; // Reset to initial state
                }

                count = 0; // Reset the count after scanning
            }
            else
            {
                if (wifiSelect != nullptr)
                {
                    wifiSelect->Update(); // Continuously update the select list if it exists
                }
                count++; // Increment the count until the next scan
            }
        }
    }
    catch (const std::exception &e)
    {
        // Handle any unexpected errors
        lcd.clear();
        lcd.setCursor(0, 1);
        lcd.print("Error occurred:");
        lcd.setCursor(0, 2);
        lcd.print(e.what()); // Display error message
        delay(3000);         // Display error for 3 seconds
        wifiIndex = -2;
        state = 0;
    }
}

#endif //

//filepath: ardulino-os.ino
#include "./config.hpp"

#include "./utils/index.hpp"
#include "./utils/structs/draw-keybord-meta-data.hpp"
#include "./globals.hpp"
#include "./wifi/on-wifi-change.hpp"
#include "./utils/structs/clickable.hpp"
#include "./data/index.hpp"
#include "./cursor.hpp"
#include "./read/index.hpp"
#include "./utils/index.hpp"
#include "./app-renderer.hpp"
#include "./auth.hpp"
#include "./init.hpp"

void setup()
{
  InitializeApps();
  WifiMenager::Update();
  Init();
  Auth();
}

void loop()
{
  WifiMenager::Update();
  AppRender::UpdateCurrentApp();
  AppRender::Update();
}

//filepath: auth.hpp
#ifndef AUTH_HPP
#define AUTH_HPP

#include "./globals.hpp"

#include "./apps/create-account/index.hpp"
#include "./apps/login/index.hpp"

#include "./data/index.hpp"
#include "./app-renderer.hpp"

void Auth()
{
    while (!isLoggedIn)
    {
        if (!data::auth::accountExists())
        {
            CreateAccountApp::Create();
        }
        else
        {
            LoginApp::Update();
            AppRender::Update();
        }
    }
    AppRender::appOpened = "home";
    ClearAppScreen();
}

#endif

//filepath: config.hpp
#include "Arduino.h"

#define IS_IN_DEBUG_LOGGED_IN true
#define LED_BUILTIN 2

//filepath: cursor.hpp
#ifndef CURSOR_HPP
#define CURSOR_HPP

#include "./globals.hpp"
#include "./utils/structs/pos.hpp"
#include "./utils/index.hpp"

namespace Cursor
{
  Pos pos = {10, 2};

  int last = 3;
  bool cursorFrameState = 0;

  void UpdateCursorFrameState()
  {
    if (last-- == 0)
    {
      cursorFrameState = !cursorFrameState;
      lcd.createChar(cursor_charcode, cursorChar[cursorFrameState]);
      last = 3;
    }
  }

  void Draw()
  {
    UpdateCursorFrameState();
    lcd.setCursor(pos.x, pos.y);
    lcd.write(0);
  }

  void Update()
  {
    int h = utils::normalizeJoystick(xPin); // get the horizontal joystick input
    int v = utils::normalizeJoystick(yPin); // get the vertical joystick input

    // move cursor
    if (h > 0 && pos.x < 19)
      pos.x++;

    if (h < 0 && pos.x > 0)
      pos.x--;

    if (v < 0 && pos.y < 3)
      pos.y++;

    if (v > 0 && pos.y > 0)
      pos.y--;

    // move cursor fast
    if (h > 1 && pos.x < 19)
      pos.x++;

    if (h < -1 && pos.x > 0)
      pos.x--;

    Draw();
  }

  template <typename BypassedType>
  Pos Get(void (*bevorUpdate)(Pos, BypassedType), BypassedType bypassed)
  {
    // static int round = 0;
    while (digitalRead(swPin) != LOW)
    {
      bevorUpdate(pos, bypassed);
      Update();
      delay(RENDERING_FRAME);
    }
    while (digitalRead(swPin) != HIGH);
    return pos;
  }
};

#endif

//filepath: data\auth.hpp
#ifndef DATA_AUTH_HPP
#define DATA_AUTH_HPP

#include "../globals.hpp"
#include "./strings.hpp"
#include "./index.hpp"

namespace auth
{
#define IS_AUTH_BYTE 10

    bool accountExists()
    {
        return data::readFromEEPROM(HAS_ACCOUNT_ADRESS) == byte(IS_AUTH_BYTE);
    }

    char *getPassword()
    {
        return strings::readStoredString(PASSWORD_ADRESS, 6);
    }

    void createAccount(String *password)
    {
        strings::storeString(PASSWORD_ADRESS, password, 6);
        data::writeToEEPROM(HAS_ACCOUNT_ADRESS, byte(IS_AUTH_BYTE));
        isLoggedIn = true;
    }

    bool isRightPassword(const char *password)
    {
#if IS_IN_DEBUG_LOGGED_IN
        return true;
#endif
        for (int i = 0; i < 6; i++)
        {
            if (password[i] != data::readFromEEPROM(PASSWORD_ADRESS + i))
                return false;
        }
        return true;
    }
};

#endif

//filepath: data\characters.hpp
#ifndef DATA_CHARACTERS_HPP
#define DATA_CHARACTERS_HPP

// predefined character codes
#define cursor_charcode 0
#define confirm_charcode 1
#define upArrowChar 2
#define downArrowChar 3

// custum characters
uint8_t cursorChar[2][8] = {
    {
        B00000,
        B00100,
        B01110,
        B11111,
        B00100,
        B00100,
        B00100,
        B00000,
    },
    {
        B00000,
        B00100,
        B01110,
        B10101,
        B00100,
        B00100,
        B00100,
        B00000,
    }};

uint8_t confirmChar[8] = {
    B00000,
    B00001,
    B00001,
    B00010,
    B00010,
    B10100,
    B01100,
    B00000,
};

// Define custom characters for up and down arrows
byte upArrow[8] = {
    B00000,
    B00100,
    B01010,
    B10001,
    B00000,
    B00000,
    B00000,
    B00000,
};

byte downArrow[8] = {
    B00000,
    B00000,
    B00000,
    B00000,
    B10001,
    B01010,
    B00100,
    B00000,
};

#endif

//filepath: data\index.hpp
#ifndef DATA_INDEX_HPP
#define DATA_INDEX_HPP

#include "../globals.hpp"

namespace data
{
    void writeToEEPROM(int address, byte value)
    {
        EEPROM.write(address, value);
        EEPROM.commit();
    }

    byte readFromEEPROM(int address)
    {
        return EEPROM.read(address);
    }

#include "./strings.hpp"
#include "./auth.hpp"
};

#endif

//filepath: data\strings.hpp
#ifndef DATA_STRINGS_HPP
#define DATA_STRINGS_HPP

#include "./index.hpp"

namespace strings
{
  char *readStoredString(int adress, int length)
  {
    char out[length];

    for (int i = 0; i < length; i++)
    {
      out[i] = data::readFromEEPROM(adress + i);
    }

    return out;
  }

  void writeStringInBuffer(char *buffer, int adress, int length)
  {
    for (int i = 0; i < length; i++)
    {
      buffer[i] = data::readFromEEPROM(adress + i);
    }
  }

  void storeString(int adress, String *str, int length)
  {
    for (int i = 0; i < length; i++)
    {
      data::writeToEEPROM(adress + i, str->charAt(i));
    }
  }
};

#endif

//filepath: extern.hpp
#ifndef EXTERN_HPP
#define EXTERN_HPP

#include <iterator>
#include <NTPClient.h>
#include <WiFiUdp.h>
#include <FS.h>
#include <LittleFS.h>
#include <Wire.h>
#include <map>
#include <WiFi.h>
#include <EEPROM.h>
#include <freertos/FreeRTOS.h>
#include <freertos/task.h>
#include <LiquidCrystal_I2C.h>
#include <HTTPClient.h>
#include <vector>;

#endif

//filepath: globals.hpp
#ifndef GLOBALS_HPP
#define GLOBALS_HPP

#include "./extern.hpp"
#include "./utils/structs/stored-map.hpp"
#include "./wifi/async-connect.hpp"
#include "./data/characters.hpp"
#include "./time.hpp"

LiquidCrystal_I2C lcd(0x27, 20, 4);

// Max memory pointer
#define MAX_MEM_PTR 2048
#define EEPROM_SIZE 512

// horizontal joystick pin
#define xPin 32
// vertical joystick pin
#define yPin 33
// joystick button pin
#define swPin 4
// LED pin
#define ledPin LED_BUILTIN

// input
#define RENDERING_FRAME 100

#define GET_CHAR_NO_CHAR 0
#define GET_CHAR_LEFT_SHIFT 1
#define GET_CHAR_RIGHT_SHIFT 2
#define GET_CHAR_SUBMIT 3
#define GET_CHAR_BACKSPACE 4
#define GET_CHAR_DELETE_ALL 5

String keyBoardLayout[2] = {
    "abcdefghij0123456789",
    "klmnopqrstuvwxyz .?!"};

int CURSOR_OFFSET = 15;

// storage

#define HAS_ACCOUNT_ADRESS 0
#define PASSWORD_ADRESS 1

// app

char appScreenData[19][3];
char appTitle[16];

void SetAppTitle(char *title, int length)
{
  for (int i = 0; i < 16; i++)
  {
    if (i < length)
      appTitle[i] = title[i];
    else
      appTitle[i] = ' ';
  }
}

void ClearAppScreen()
{

  for (int y = 0; y < 3; y++)
    for (int x = 0; x < 19; x++)
      appScreenData[x][y] = ' ';
}

// auth

bool isLoggedIn = false;

// custum characters
#include "./data/characters.hpp"

int testIndex = 0;
void test(char *title = "")
{
  testIndex++;
  lcd.clear();
  lcd.home();
  lcd.print(title);
  lcd.setCursor(0, 1);
  lcd.print(testIndex);

  Serial.println(title);
  Serial.println(testIndex);
  delay(1000);
}

void InitData()
{
  for (int i = 0; i < 16; i++)
    appTitle[i] = ' ';

  ClearAppScreen();
}

#endif

//filepath: init-apps.hpp
#ifndef INIT_APPS_HPP
#define INIT_APPS_HPP

#include "./globals.hpp"
#include "./app-renderer.hpp"

#include "./apps/browser/index.hpp"
#include "./apps/wifi/index.hpp"
#include "./apps/login/index.hpp"
#include "./apps/home/index.hpp"
#include "./apps/eeprom-editor/index.hpp"
#include "./apps/memory-editor/index.hpp"
#include "./apps/flash-light/index.hpp"
#include "./apps/pin-menager/index.hpp"
#include "./apps/clock/index.hpp"

// Define prototypes for each app
AppPrototype homeApp = {
    "home",
    nullptr, // Start
    HomeApp::Update,
    HomeApp::Scroll,  // Scroll
    nullptr,          // OnExit
    HomeApp::OnClick, // OnClick
    HomeApp::Submit,
};

AppPrototype browserApp = {
    "browser",
    nullptr, // Start
    BrowserApp::Update,
    nullptr, // Scroll
    BrowserApp::OnExit,
    BrowserApp::OnClick,
    nullptr, // Submit
};

AppPrototype wifiApp = {
    "wifi",
    nullptr, // Start
    WifiApp::Update,
    WifiApp::Scroll,
    nullptr, // OnExit
    WifiApp::OnClick,
    WifiApp::Submit,
};

AppPrototype loginApp = {
    "login",
    nullptr, // Start
    LoginApp::Update,
    LoginApp::Scroll,
    nullptr, // OnExit
    LoginApp::OnClick,
    nullptr, // Submit
};

AppPrototype eepromEditorApp = {
    "eeprom-editor",
    nullptr, // Start
    EEPROMEditor::Update,
    EEPROMEditor::Scroll,
    nullptr, // OnExit
    nullptr, // OnClick
    EEPROMEditor::Submit,
};

AppPrototype memoryEditorApp = {
    "memory-editor",
    nullptr, // Start
    MemoryEditor::Update,
    MemoryEditor::Scroll,
    nullptr, // OnExit
    nullptr, // OnClick
    MemoryEditor::Submit,
};

AppPrototype flashLightApp = {
    "flash-light",
    nullptr, // Start
    FlashLightApp::Update,
    nullptr,                // Scroll
    nullptr,                // OnExit
    FlashLightApp::OnClick, // OnClick
    FlashLightApp::Submit,
};

AppPrototype pinManagerApp = {
    "pin-menager",
    nullptr, // Start
    PinMengerApp::Update,
    PinMengerApp::Scroll,
    nullptr,               // OnExit
    PinMengerApp::OnClick, // OnClick
    PinMengerApp::Submit,
};

AppPrototype clockApp = {
    "clock",
    nullptr, // Start
    ClockApp::Update,
    ClockApp::Scroll,
    nullptr,           // OnExit
    ClockApp::OnClick, // OnClick
    ClockApp::Submit,
};

// Register all app prototypes at initialization
void InitializeApps()
{
    RegisterApp(homeApp);
    RegisterApp(browserApp);
    RegisterApp(wifiApp);
    RegisterApp(loginApp);
    RegisterApp(eepromEditorApp);
    RegisterApp(memoryEditorApp);
    RegisterApp(flashLightApp);
    RegisterApp(pinManagerApp);
    RegisterApp(clockApp);
}

#endif


//filepath: init.hpp
#ifndef INIT_HPP
#define INIT_HPP

#include "./globals.hpp"

void Init()
{
    // lcd display
    lcd.init();
    lcd.backlight();
    // serial
    Serial.begin(9600);
    Serial.println("Starting");
    // eeprom
    EEPROM.begin(EEPROM_SIZE);
    FlashHashMap::begin();
    // create characters
    lcd.createChar(cursor_charcode, cursorChar[0]);
    lcd.createChar(confirm_charcode, confirmChar);
    lcd.createChar(upArrowChar, upArrow);
    lcd.createChar(downArrowChar, downArrow);
    // pin modes
    pinMode(swPin, INPUT_PULLUP);
    pinMode(ledPin, OUTPUT);
    // init screen data
    InitData();
    AsyncWifiConnect();
    // init the time
    Time::Init();
    // init home app (get home links from fs...)
    HomeApp::Init();
}

#endif

//filepath: read\draw-key-board.hpp
#ifndef READ_DRAW_KEY_BOARD_HPP
#define READ_DRAW_KEY_BOARD_HPP

#include "../utils/structs/pos.hpp"
#include "../utils/structs/draw-keybord-meta-data.hpp"
#include "../globals.hpp"
#include "../cursor.hpp"
#include "./index.hpp"

void DrawKeyBoard(Pos cursorPos, DrawKeyBoardMetaData *drawKeyBoardMetaData)
{
  // promt layout
  if (!cursorPos.collidesWith({0, 0}))
  {
    lcd.home();
    lcd.write('<');
  }
  if (!cursorPos.collidesWith({19, 0}))
  {
    lcd.setCursor(19, 0);
    lcd.write('>');
  }

  // Assuming drawKeyBoardMetaData and lcd are properly initialized and available
  int promptLength = drawKeyBoardMetaData->prompt->length();

  for (int i = 1; i < 18; i++)
  {
    int writeCharindex = i - (CURSOR_OFFSET + 1) + drawKeyBoardMetaData->writePos;

    if (i < (CURSOR_OFFSET + 1))
    {
      if (!cursorPos.collidesWith({i, 0}))
      {
        lcd.setCursor(i, 0);

        if (writeCharindex < promptLength && writeCharindex > -1)
          lcd.write(drawKeyBoardMetaData->prompt->charAt(writeCharindex));
        else
          lcd.write(' ');
      }
    }
    else
    {
      if (!cursorPos.collidesWith({i + 1, 0}))
      {
        lcd.setCursor(i + 1, 0);

        if (writeCharindex < promptLength && writeCharindex > -1)
          lcd.write(drawKeyBoardMetaData->prompt->charAt(writeCharindex));
        else
          lcd.write(' ');
      }
    }
  }

  // text cursor
  if (!cursorPos.collidesWith({(CURSOR_OFFSET + 1), 0}))
  {
    lcd.setCursor((CURSOR_OFFSET + 1), 0);
    lcd.write(Cursor::cursorFrameState ? 'I' : '|');
  }

  // draw alphabetics layout
  for (int i = 0; i < 20; i++)
  {
    if (!cursorPos.collidesWith({i, 1}))
    {
      lcd.setCursor(i, 1);
      lcd.write(currentCharUpperCase ? toupper(keyBoardLayout[0][i]) : keyBoardLayout[0][i]);
    }
    if (!cursorPos.collidesWith({i, 2}))
    {
      lcd.setCursor(i, 2);
      lcd.write(currentCharUpperCase ? toupper(keyBoardLayout[1][i]) : keyBoardLayout[1][i]);
    }
  }

  // clear last row
  // clear part bevore buttons
  for (int i = 1; i < 11; i++)
  {
    if (!cursorPos.collidesWith({i, 3}))
    {
      lcd.setCursor(i, 3);
      lcd.write(' ');
    }
  }
  // clear between buttons
  for (int i = 11; i < 19; i++)
  {
    // only draw if the cursor isnt on the pos and its every fist of 2
    if (!cursorPos.collidesWith({i, 3}) && i % 2 == 0)
    {
      lcd.setCursor(i, 3);
      lcd.write(' ');
    }
  }

  // non alfabetic characters
  if (!cursorPos.collidesWith({11, 3}))
  {
    lcd.setCursor(11, 3);
    lcd.write('#');
  }

  // Delete all
  if (!cursorPos.collidesWith({13, 3}))
  {
    lcd.setCursor(13, 3);
    lcd.write('X');
  }

  // Uppercase and Lowercase
  if (!cursorPos.collidesWith({15, 3}))
  {
    lcd.setCursor(15, 3);
    lcd.write('x');
  }

  // Uppercase and Lowercase
  if (!cursorPos.collidesWith({17, 3}))
  {
    lcd.setCursor(17, 3);
    lcd.write(currentCharUpperCase ? 'a' : 'A');
  }

  // confirm
  if (!cursorPos.collidesWith({19, 3}))
  {
    lcd.setCursor(19, 3);
    lcd.write(confirm_charcode);
  }

  // selected
  lcd.setCursor(0, 3);
  if (cursorPos.y == 1 || cursorPos.y == 2)
  {
    lcd.setCursor(0, 3);
    lcd.write(currentCharUpperCase ? toupper(keyBoardLayout[cursorPos.y - 1].charAt(cursorPos.x)) : keyBoardLayout[cursorPos.y - 1].charAt(cursorPos.x));
  }
  else if (cursorPos.y == 0)
  {
    lcd.write(cursorPos.x == 0 ? '<' : (cursorPos.x == 19 ? '>' : '-'));
  }
  else if (cursorPos.collidesWith({11, 3}))
  {
    lcd.write('#');
  }
  else if (cursorPos.collidesWith({15, 3}))
  {
    lcd.write('x');
  }
  else if (cursorPos.collidesWith({13, 3}))
  {
    lcd.write('X');
  }
  else if (cursorPos.collidesWith({17, 3}))
  {
    lcd.write(currentCharUpperCase ? 'a' : 'A');
  }
  else if (cursorPos.collidesWith({19, 3}))
  {
    lcd.write(confirm_charcode);
  }
  else
  {
    lcd.write('-');
  }
}

#endif

//filepath: read\get-byte.hpp
#ifndef READ_GET_BYTE_HPP
#define READ_GET_BYTE_HPP

#include "../globals.hpp"
#include "../utils/index.hpp"

unsigned char getByte(char *msg, unsigned char byteNum, int msgPos = 6)
{
    lcd.clear();
    while (digitalRead(swPin) != LOW)
    {
        // new val text
        lcd.setCursor(msgPos, 1);
        lcd.print(msg);
        lcd.setCursor(9, 2);
        // current number
        lcd.print("   ");
        lcd.print(byteNum);
        // char
        lcd.setCursor(7, 2);
        lcd.write(byteNum);
        // increase or decrease bytenum
        auto verticalJoystick = utils::normalizeJoystick(yPin);
        //no positive overflow
        if ((byteNum == 253 && verticalJoystick == 2) || (byteNum == 254 && verticalJoystick == 1))
        {
            byteNum = 0;
        }
        //no negative overflow
        if ((byteNum == 3 && verticalJoystick == -2) || (byteNum == 2 && verticalJoystick == -1))
        {
            byteNum = 255;
        }
        else
        {
            byteNum += verticalJoystick;
        }

        delay(RENDERING_FRAME);
    }

    while ((digitalRead(swPin) == LOW))
        ;
    lcd.clear();
    return byteNum;
}

#endif

//filepath: read\index.hpp
#ifndef READ_INDEX_HPP
#define READ_INDEX_HPP

#include <ctype.h>

bool currentCharUpperCase = false;

namespace input
{
#include "./get-byte.hpp"
#include "./draw-key-board.hpp"
#include "./read-char.hpp"
#include "./read-string.hpp"
};

#endif

//filepath: read\read-char.hpp
#ifndef READ_READ_CHAR_HPP
#define READ_READ_CHAR_HPP

#include "./draw-key-board.hpp"
#include "../read/index.hpp"

char ReadChar(DrawKeyBoardMetaData *drawKeyBoardMetaData)
{
  Pos cursorPos = Cursor::Get<DrawKeyBoardMetaData *>(DrawKeyBoard, drawKeyBoardMetaData);

  digitalWrite(ledPin, HIGH);
  while (digitalRead(swPin) == LOW)
    ;
  digitalWrite(ledPin, LOW);

  // characters
  if (cursorPos.y == 1 || cursorPos.y == 2)
  {
    char currentChar = keyBoardLayout[cursorPos.y - 1].charAt(cursorPos.x);
    return currentCharUpperCase ? toupper(currentChar) : currentChar;
  }

  // left scroll
  if (cursorPos.collidesWith({0, 0}))
  {
    return GET_CHAR_LEFT_SHIFT;
  }

  // right scroll
  if (cursorPos.collidesWith({19, 0}))
  {
    return GET_CHAR_RIGHT_SHIFT;
  }

  //
  if (cursorPos.collidesWith({11, 3}))
  {
    return input::getByte("special char:", '#', 3);
  }

  // backspace
  if (cursorPos.collidesWith({15, 3}))
  {
    return GET_CHAR_BACKSPACE;
  }

  // uppercase and lowercase
  if (cursorPos.collidesWith({17, 3}))
  {
    currentCharUpperCase = !currentCharUpperCase;
    DrawKeyBoard(cursorPos, drawKeyBoardMetaData);
    delay(RENDERING_FRAME);
    return ReadChar(drawKeyBoardMetaData);
  }

  // submit
  if (cursorPos.collidesWith({19, 3}))
    return GET_CHAR_SUBMIT;

  //
  if (cursorPos.collidesWith({13, 3}))
    return GET_CHAR_DELETE_ALL;

  return ReadChar(drawKeyBoardMetaData);
}

#endif

//filepath: read\read-string.hpp
#ifndef READ_READ_STRING_HPP
#define READ_READ_STRING_HPP

#include "../utils/structs/pos.hpp"
#include "../utils/structs/draw-keybord-meta-data.hpp"
#include "../globals.hpp"
#include "../cursor.hpp"
#include "./read-char.hpp"

String *ReadString(DrawKeyBoardMetaData drawKeyBoardMetaData)
{
  lcd.clear();
  char out;

  while (true)
  {
    out = ReadChar(&drawKeyBoardMetaData);

    if (out == GET_CHAR_LEFT_SHIFT && drawKeyBoardMetaData.writePos > 0)
    {
      drawKeyBoardMetaData.writePos--;
    }
    else if (out == GET_CHAR_RIGHT_SHIFT && drawKeyBoardMetaData.writePos < drawKeyBoardMetaData.prompt->length())
    {
      drawKeyBoardMetaData.writePos++;
    }
    else if (out == GET_CHAR_BACKSPACE)
    {
      drawKeyBoardMetaData.prompt->remove(drawKeyBoardMetaData.writePos - 1, 1);
      drawKeyBoardMetaData.writePos--;
    }
    else if (out == GET_CHAR_SUBMIT)
    {
      break;
    }
    else if (out == GET_CHAR_DELETE_ALL)
    {
      *drawKeyBoardMetaData.prompt = "";
      drawKeyBoardMetaData.writePos = 0;
    }
    else if (isascii(out))
    {
      *drawKeyBoardMetaData.prompt = drawKeyBoardMetaData.prompt->substring(0, drawKeyBoardMetaData.writePos) + out + drawKeyBoardMetaData.prompt->substring(drawKeyBoardMetaData.writePos);
      drawKeyBoardMetaData.writePos++;
    };

    delay(RENDERING_FRAME);
  }

  lcd.clear();
  lcd.print(drawKeyBoardMetaData.prompt->c_str());

  delay(1000);
  lcd.clear();

  return drawKeyBoardMetaData.prompt;
}

#endif

//filepath: time.hpp
#ifndef TIME_HPP
#define TIME_HPP

#include "./globals.hpp"
#include "./wifi/on-wifi-change.hpp"

// Update interval for NTP time (in milliseconds)
const long utcOffsetInSeconds = 0; // Set your UTC offset here

namespace Time
{
    WiFiUDP ntpUDP;
    NTPClient timeClient(ntpUDP, "pool.ntp.org", utcOffsetInSeconds);

    unsigned long startTimeOffset = 0;

    void UpdateData(bool isConnected)
    {
        if (!isConnected)
            return;
        timeClient.begin();
        while (!timeClient.update())
        {
            timeClient.forceUpdate(); // Fetch time from NTP server
        }
        startTimeOffset = timeClient.getEpochTime() - millis();
    }

    unsigned long GetTime()
    {
        return startTimeOffset + millis();
    }

    void Init()
    {
        WifiMenager::onWifiChangeCallback.Add(UpdateData);
    }
};

using Time::GetTime;

#endif


//filepath: utils\index.hpp
#ifndef UTILS_INDEX_HPP
#define UTILS_INDEX_HPP

#include "../globals.hpp"

namespace utils
{
  void waitForRelease()
  {
    while (digitalRead(swPin) != LOW)
      ;
    lcd.clear();
    lcd.setCursor(4, 1);
    lcd.print("release key");
    digitalWrite(LED_BUILTIN, HIGH);
    while (digitalRead(swPin) == LOW)
      ;
    digitalWrite(LED_BUILTIN, LOW);
    lcd.clear();
  }

  void print(int x, int y, char *text, int length)
  {
    for (int i = 0; i < length; i++)
    {
      appScreenData[i + x][y] = text[i];
    }
  }

  void cantExitApp()
  {
    lcd.clear();
    lcd.setCursor(3, 1);
    lcd.print("Can't Exit App");
    delay(2000);
    lcd.clear();
  }

  char *sizeString(char *inp, byte length)
  {
    char out[length];
    for (byte i = 0; i < length; i++)
      out[i] = inp[i];
    return out;
  }

  int8_t normalizeJoystick(uint8_t pin)
  {
    int val = analogRead(pin);
    if (val == 4095) // Close to the maximum for a 12-bit ADC
      return 2;
    if (val == 0) // Close to the minimum
      return -2;
    if (val > 3000) // Close to the upper range
      return 1;
    if (val < 2000) // Close to the lower range
      return -1;
    return 0;
  }

  String setStringSize(const String &str, int size)
  {
    int length = str.length();
    if (length == size)
      return str; // Return by value

    if (length > size)
    {
      return str.substring(0, size); // Return a trimmed version by value
    }

    String newStr;
    for (int i = 0; i < size; i++)
    {
      newStr += i < length ? str.charAt(i) : ' '; // Pad with spaces if needed
    }

    return newStr; // Return the new string by value
  }

};

#endif

//filepath: utils\structs\clickable.hpp
#ifndef UTILS_STRUCTS_CLICKABLE_HPP
#define UTILS_STRUCTS_CLICKABLE_HPP

#include "../../globals.hpp"
#include "./pos.hpp"

struct Clickable
{
    byte y;
    byte start;
    byte end;
    char *text;
    byte stringLength;

    void Draw()
    {
        appScreenData[start][y] = '[';

        for (byte i = start + 1; i < end - 1; i++)
        {
            appScreenData[i][y] = i - start - 1 < stringLength ? text[i - start - 1] : ' ';
        }

        appScreenData[end - 1][y] = ']';
    }

    bool collidesWith(const Pos &other) const
    {
        return (other.y - 1) == y && other.x >= start && other.x <= end;
    }
};

Clickable Button(byte y, byte x, const String &text)
{
    Clickable button;
    button.y = y;
    button.start = x;
    button.end = x + text.length() + 2;

    // Allocate a buffer and copy the text into it
    char *buffer = new char[text.length() + 1];  // +1 for the null terminator
    text.toCharArray(buffer, text.length() + 1); // Copy text into the buffer
    button.text = buffer;

    button.stringLength = text.length();
    return button;
}

#define Btn Clickable

#endif

//filepath: utils\structs\dblist.hpp
#ifndef UTILS_STRUCTS_DBLIST_HPP
#define UTILS_STRUCTS_DBLIST_HPP

#include "Scaleist;.hppkeys"

template <typename KeyType, typename ValueType, typename SizeType>
struct DbList
{
    Scaleist<KeyType, SizeType> keys;
    List<ValueType, SizeType> values;

    bool hasKey(KeyType key)
    {
        for (SizeType i = 0; i < keys.size; i++)
        {
            if (keys.data[i] == key)
                return true;
        }
        return false;
    }

    bool hasValue(ValueType value)
    {
        for (SizeType i = 0; i < keys.size; i++)
        {
            if (keys.data[i] == value)
                return true;
        }
        return false;
    }

    bool indexOfKey(KeyType key)
    {
        for (SizeType i = 0; i < keys.size; i++)
        {
            if (keys.data[i] == key)
                return i;
        }
        return -1;
    }

    bool indexOfValue(ValueType value)
    {
        for (SizeType i = 0; i < keys.size; i++)
        {
            if (keys.data[i] == value)
                return i;
        }
        return -1;
    }

    void Add(KeyType key, ValueType value)
    {
        keys.Scale(keys.size + 1);
        values.Scale(values.size + 1);
    }

    KeyType GetKey(ValueType value)
    {
        SizeType pos = indexOfValue(value);
        if (pos == -1)
        {
            return NULL;
        }
        return keys.data[pos];
    }

    ValueType GetValue(KeyType key)
    {
        SizeType pos = indexOfKey(key);
        if (pos == -1)
        {
            return NULL;
        }
        return values.data[pos];
    }

    bool SetKey(ValueType value, KeyType newKey)
    {
        SizeType pos = indexOfValue(value);
        if (pos == -1)
        {
            return false;
        }
        keys.data[pos] = newKey;
        return true;
    }

    bool SetValue(KeyType key, ValueType newValue)
    {
        SizeType pos = indexOfKey(key);
        if (pos == -1)
        {
            return false;
        }
        values.data[pos] = newValue;
        return true;
    }
};

#endif


//filepath: utils\structs\draw-keybord-meta-data.hpp
#ifndef UTILS_STRUCTS_DRAW_KEYBOARD_META_DATA_HPP
#define UTILS_STRUCTS_DRAW_KEYBOARD_META_DATA_HPP

struct DrawKeyBoardMetaData
{
    unsigned int writePos;
    String *prompt;
};

#endif

//filepath: utils\structs\input.hpp
#ifndef UTILS_STRUCTS_INPUT_HPP
#define UTILS_STRUCTS_INPUT_HPP

#include "./../../globals.hpp"
#include "./../../read/index.hpp"
#include "./../../utils/index.hpp"

struct Input
{
    byte y;
    byte start;        // Start position (X coordinate) of the input field
    byte end;          // End position (X coordinate) of the input field
    char *placeholder; // Placeholder text when the input is empty
    String value;      // User input value

    // Constructor to initialize the input field
    Input(byte _y, byte _start, byte _end, const char *_placeholder, String _value = "")
    {
        y = _y;
        start = _start;
        end = _end;
        placeholder = new char[strlen(_placeholder) + 1];
        strcpy(placeholder, _placeholder);
        value = _value;
    }

    // Draw the input field
    void Draw()
    {
        String toDisplay = value.isEmpty() ? String(placeholder) : value;

        // Adjust the size of the string based on available space between start and end
        toDisplay = utils::setStringSize(toDisplay, end - start - 2);

        // Draw the input field with <value> markers
        appScreenData[start][y] = '<';
        for (byte i = start + 1; i < end - 1; i++)
        {
            appScreenData[i][y] = i - start - 1 < toDisplay.length() ? toDisplay[i - start - 1] : ' ';
        }
        appScreenData[end - 1][y] = '>';
    }

    // Handle clicks, directly open input for typing
    void OnClick(const Pos &clickPosition)
    {
        if (clickPosition.y - 1 == y && clickPosition.x >= start && clickPosition.x <= end)
        {
            // Open the input method and update the value
            value = *input::ReadString(DrawKeyBoardMetaData{value.length(), &value});
        }
    }
};

#endif


//filepath: utils\structs\list.hpp
#ifndef UTILS_STRUCTS_LIST_HPP
#define UTILS_STRUCTS_LIST_HPP

#include <new> // Include for placement new

template <typename T, typename SizeType>
struct List
{
    SizeType size = 0;
    T *data = nullptr;

    List(SizeType length)
    {
        Scale(length); // Initialize the list with the specified length
    }

    List(T *_data)
    {
        data = _data;
    }

    ~List()
    {
        if (data != nullptr)
        {
            // Call the destructor for each element in the array
            for (SizeType i = 0; i < size; i++)
            {
                data[i].~T();
            }
            delete[] reinterpret_cast<char *>(data); // Free allocated memory
        }
    }

    void Scale(SizeType itemCount)
    {
        // Allocate memory for the array without calling constructors
        T *newData = reinterpret_cast<T *>(new char[itemCount * sizeof(T)]);
        SizeType writeLength = size > itemCount ? itemCount : size;

        // Copy existing data to the new array
        for (SizeType i = 0; i < writeLength; i++)
        {
            new (&newData[i]) T(data[i]); // Placement new to copy construct
            data[i].~T();                 // Destroy old object
        }

        // Free the old memory
        if (data != nullptr)
        {
            delete[] reinterpret_cast<char *>(data); // Cast back to char for deletion
        }

        // Update the size and data pointer
        size = itemCount;
        data = newData;
    }

    SizeType Find(T item)
    {
        for (SizeType i = 0; i < size; i++)
        {
            if (data[i] == item)
            {
                return i;
            }
        }
        return -1;
    }

    void Add(T item)
    {
        Scale(size + 1);
        data[size] = item;
    }
};

#endif


//filepath: utils\structs\pos.hpp
#ifndef UTILS_STRUCTS_POS_HPP
#define UTILS_STRUCTS_POS_HPP

struct Pos
{
  byte x = 0;
  byte y = 0;

  Pos(byte cx, byte cy)
  {
    x = cx;
    y = cy;
  }

  bool canDraw()
  {
    // is in screen
    return x > -1 && x < 20 && y < 4 && y > -1;
  }

  bool collidesWith(const Pos &other)
  {
    return x == other.x && y == other.y;
  }
};

#endif

//filepath: utils\structs\select.hpp
#ifndef UTILS_STRUCTS_SELECT_HPP
#define UTILS_STRUCTS_SELECT_HPP

#include "../../globals.hpp"
#include "../../cursor.hpp"
#include "./pos.hpp"

struct Select
{
    String *options;
    byte optionsLength;
    byte pos;

    void Scroll(signed char direction)
    {
        if (direction < 0 && pos + 1 < optionsLength - 1 && pos - 1 < optionsLength - 1)
            pos++;
        else if (direction > 0 && pos + 1 > 0 && pos - 1 > 0)
            pos--;
    }

    byte cursorPos = 1;
    void Update()
    {
        // set the cursor pos only if the cursor is on screen data 0-3
        cursorPos = Cursor::pos.y == 0 || Cursor::pos.x == 19 ? cursorPos : Cursor::pos.y - 1;
        // add the select
        appScreenData[0][0] = ' ';
        appScreenData[0][1] = ' ';
        appScreenData[0][2] = ' ';
        // set the pointer
        appScreenData[0][cursorPos] = '>';

        // draw the options
        for (int optionIndex = 0; optionIndex < 3; optionIndex++)
        {
            for (int charIndex = 0; charIndex < 18; charIndex++)
            {
                byte optionPos = optionIndex + pos - 1;

                bool isOutOfOptionBound = optionPos < 0 || optionPos > optionsLength - 1;
                bool charIsntInStringBounds = options[optionPos].length() < charIndex + 1;

                if (isOutOfOptionBound || charIsntInStringBounds)
                {
                    appScreenData[charIndex + 1][optionIndex] = ' ';
                }
                else
                {
                    appScreenData[charIndex + 1][optionIndex] = options[optionPos].charAt(charIndex);
                }
            }
        }
    }

    byte OnClick()
    {
        byte returnPos = pos + cursorPos - 1;

        if (returnPos < 0 || returnPos > optionsLength - 1)
            return -1;

        return returnPos;
    }
};

#endif

//filepath: utils\structs\stored-map.hpp
#ifndef UTILS_STRUCTS_STORED_MAP
#define UTILS_STRUCTS_STORED_MAP

#include "../../globals.hpp"
#include <base64.h> // Include Base64 library (you may need to install it)

struct FlashHashMap
{
    String root;

    // Constructor to initialize the root directory with the escaped map ID
    FlashHashMap(const String &mapId)
    {
        root = "/maps/" + base64Encode(mapId) + "/"; // Set the root directory based on Base64 encoded map ID
        createDirectory();                           // Create the directory if it doesn't exist
    }

    // Method to begin LittleFS
    static void begin()
    {
        LittleFS.begin();
    }

    // Method to Base64 encode keys and map IDs
    String base64Encode(const String &key)
    {
        String encoded = base64::encode((const uint8_t *)key.c_str(), key.length());
        encoded.replace("=", "_"); // Replace padding character
        encoded.replace("/", "_"); // Replace with underscore or any other safe character
        encoded.replace("+", "-"); // Replace with a hyphen or any other safe character
        return encoded;
    }

    // Method to create the root directory if it doesn't exist
    void createDirectory()
    {
        if (!LittleFS.exists("/maps/"))
        {
            LittleFS.mkdir("/maps/");
        }

        if (!LittleFS.exists(root))
        {
            LittleFS.mkdir(root);
        }
    }

    // Check if a file exists
    bool fileExists(const String &filePath)
    {
        return LittleFS.exists(filePath);
    }

    // Method to set a key-value pair
    void set(const String &key, const String &value)
    {
        String escapedKey = base64Encode(key);      // Base64 encode the key to make it valid
        String filePath = root + escapedKey + ".v"; // Construct the full file path with ".v"

        // Create the file
        File file = LittleFS.open(filePath, fileExists(filePath) ? "w" : "w+", !fileExists(filePath));
        file.print(value); // Write to the file
        file.close();
    }

    // Method to get a value by key
    String get(const String &key)
    {
        String escapedKey = base64Encode(key);      // Base64 encode the key to make it valid
        String filePath = root + escapedKey + ".v"; // Construct the full file path

        File file = LittleFS.open(filePath, "r");
        String value = file.readString();
        file.close();

        return value;
    }

    // Method to check if a key exists
    bool has(const String &key)
    {
        String escapedKey = base64Encode(key);      // Base64 encode the key
        String filePath = root + escapedKey + ".v"; // Construct the full file path
        return fileExists(filePath);                // Use the fileExists method
    }

    // Method to delete a key-value pair
    void remove(const String &key)
    {
        String escapedKey = base64Encode(key);      // Base64 encode the key
        String filePath = root + escapedKey + ".v"; // Construct the full file path
        LittleFS.remove(filePath);
    }
};

#endif


//filepath: utils\structs\text.hpp
#ifndef UTILS_STRUCTS_TEXT_HPP
#define UTILS_STRUCTS_TEXT_HPP

#include "../../globals.hpp"
#include "./pos.hpp"

struct Text
{
    byte y;
    byte x;
    String text;

    void Draw()
    {
        for (byte i = 0; i < x + text.length() - 1; i++)
        {
            appScreenData[i + x][y] = text.charAt(i);
        }
    }

    bool collidesWith(const Pos &other) const
    {
        return (other.y - 1) == y && other.x >= x && other.x <= x + text.length() - 1;
    }
};

#endif

//filepath: utils\structs\wifi-data.hpp
#ifndef UTILS_STRUCTS_WIFI_DATA_HPP
#define UTILS_STRUCTS_WIFI_DATA_HPP

#include <WiFi.h>

struct WifiData
{
    String ssid;
    int32_t rssi;
    int32_t channel;
    uint8_t authMode; // Changed to uint8_t for clarity

    WifiData(int i)
    {
        // Check if index is within valid range
        if (i >= 0 && i < WiFi.scanComplete())
        {
            ssid = WiFi.SSID(i);
            rssi = WiFi.RSSI(i);
            channel = WiFi.channel(i);
            authMode = WiFi.encryptionType(i);
        }
        else
        {
            Serial.println("ERROR: Index out of range: ");
            Serial.print(i);
            ssid = "Unknown"; // Assign a default value
            rssi = 0;
            channel = 0;
            authMode = 0; // Default value for auth mode
        }
    }
};

#endif

//filepath: wifi\async-connect.hpp
#ifndef WIFI_ASYNC_CONNECT_HPP
#define WIFI_ASYNC_CONNECT_HPP

#include "../utils/structs/stored-map.hpp"
#include "../globals.hpp"

FlashHashMap wifisConnectedAsync("wifis");

void AsyncWifiTask(void *parameter)
{
    Serial.println("Starting WiFi scan...");

    try
    {
        // Set WiFi to station mode and disconnect from an AP if it was previously connected.
        WiFi.mode(WIFI_STA);
        WiFi.disconnect();
        WiFi.scanDelete();
        int wifiCount = WiFi.scanNetworks(false, true, true);

        Serial.print("Networks found: ");
        Serial.println(wifiCount);

        if (wifiCount < 1)
        {
            Serial.println("No networks found. Terminating task.");
            vTaskDelete(NULL); // No networks found, terminate the task
            return;
        }

        int wifiIndex = 0;

        // Loop through WiFi networks until a connection is made
        while (wifiIndex < wifiCount)
        {
            String ssid = WiFi.SSID(wifiIndex);
            bool isOpenNetwork = (WiFi.encryptionType(wifiIndex) == WIFI_AUTH_OPEN);

            Serial.print("Trying to connect to SSID: ");
            Serial.println(ssid);

            if (isOpenNetwork || wifisConnectedAsync.has(ssid))
            {
                String password = wifisConnectedAsync.get(ssid); // Get password if available

                // Try connecting to the network
                if (isOpenNetwork)
                {
                    Serial.print("Connecting to open network: ");
                    Serial.println(ssid);
                    WiFi.begin(ssid.c_str()); // Open network, no password
                }
                else
                {
                    Serial.print("Connecting to secured network: ");
                    Serial.println(ssid);
                    WiFi.begin(ssid.c_str(), password.c_str()); // Secured network with password
                }

                unsigned long startTime = millis();
                const unsigned long timeout = 10000; // 10-second timeout

                // Wait for connection or timeout
                while (WiFi.status() != WL_CONNECTED)
                {
                    if (millis() - startTime > timeout)
                    {
                        Serial.print("Connection to ");
                        Serial.print(ssid);
                        Serial.println(" failed. Trying next network.");
                        break; // Connection failed, move to the next network
                    }
                }

                // If connected, log the success and stop searching
                if (WiFi.status() == WL_CONNECTED)
                {
                    Serial.print("Successfully connected to ");
                    Serial.println(ssid);
                    Serial.print("IP address: ");
                    Serial.println(WiFi.localIP());
                    vTaskDelete(NULL); // Successfully connected, terminate the task
                    return;
                }
            }

            // Move to the next network if connection failed
            wifiIndex++;
        }

        // No successful connection, terminate the task
        Serial.println("No successful connection made. Terminating task.");
        vTaskDelete(NULL);
    }
    catch (...)
    {
        // Handle any errors and terminate the task
        Serial.println("An error occurred during WiFi connection attempt.");
        vTaskDelete(NULL);
    }
}

void AsyncWifiConnect()
{
    // Create a background task for asynchronous WiFi connection
    xTaskCreate(
        AsyncWifiTask,   // Task function
        "AsyncWifiTask", // Name of the task
        10000,           // Stack size (in words)
        NULL,            // Task input parameter
        1,               // Priority of the task
        NULL             // Task handle
    );
}

#endif // WIFI_ASYNC_CONNECT_HPP


//filepath: wifi\get-network-list.hpp
#ifndef WIFI_GET_NETWORK_LIST_HPP
#define WIFI_GET_NETWORK_LIST_HPP

#include "../utils/structs/select.hpp"
#include "../globals.hpp"

int WifiScanStart(
    bool showHidden = false,
    bool passive = false,
    uint32_t max_ms_per_chan = 300,
    uint8_t channel = 0,
    const char *ssid = nullptr,
    const uint8_t *bssid = nullptr)
{
    // Set WiFi to station mode and disconnect from an AP if it was previously connected.
    WiFi.mode(WIFI_STA);
    WiFi.disconnect();
    WiFi.scanDelete();
    return WiFi.scanNetworks(false, showHidden, passive, max_ms_per_chan, channel, ssid, bssid);
}

Select *GetWifiNetworkSelect(int networkCount)
{
    Select *wifiSelect = new Select();
    wifiSelect->optionsLength = networkCount;

    // Allocate new memory for the SSID list
    wifiSelect->options = new String[wifiSelect->optionsLength]; // Allocate new memory
    if (wifiSelect->options == nullptr)
    {
        ClearAppScreen();
        // Handle allocation failure
        Text(1, 1, "Allocation Failed").Draw();
        AppRender::UpdateView();
        delay(1000);
        delete wifiSelect;    // Clean up wifiSelect
        wifiSelect = nullptr; // Set pointer to nullptr after deletion
        return nullptr;       // Return null pointer if allocation failed
    }

    // Fill the SSID list
    for (byte i = 0; i < wifiSelect->optionsLength; i++)
    {
        wifiSelect->options[i] = WiFi.SSID(i);
    }

    // Set position if there are more than 2 networks
    if (wifiSelect->optionsLength > 2)
    {
        wifiSelect->pos = 1;
    }

    return wifiSelect; // Return pointer to the allocated list
}

#endif


//filepath: wifi\on-wifi-change.hpp
#ifndef WIFI_ON_WIFI_CHANGE_HPP
#define WIFI_ON_WIFI_CHANGE_HPP

#include "../globals.hpp"
#include "../utils/structs/list.hpp"

namespace WifiMenager
{
    bool isConnectedToWifi = false;

    List<void (*)(bool), int> onWifiChangeCallback(0);

    void Update()
    {
        return;
        bool isConnected = WiFi.status() == WL_CONNECTED;

        if (isConnectedToWifi != isConnected)
        {
            for (int i = 0; i < onWifiChangeCallback.size; i++)
                onWifiChangeCallback.data[i](isConnected);
        }

        isConnectedToWifi = isConnected;
    }
}

#endif
